/*++

Copyright (C) 2021 Strings developers

All rights reserved.

This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of String example library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "strexample_abi.hpp"
#include "strexample_interfaces.hpp"
#include "strexample_interfaceexception.hpp"

#include <map>

using namespace StringsExample::Impl;

StringsExampleResult handleStringsExampleException(IBase * pIBaseClass, EStringsExampleInterfaceException & Exception)
{
	StringsExampleResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

StringsExampleResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	StringsExampleResult errorCode = STRINGSEXAMPLE_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

StringsExampleResult handleUnhandledException(IBase * pIBaseClass)
{
	StringsExampleResult errorCode = STRINGSEXAMPLE_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for StringObject
**************************************************************************************************************************/
StringsExampleResult stringsexample_stringobject_getmystringobject(StringsExample_StringObject pStringObject, const StringsExample_uint32 nNameBufferSize, StringsExample_uint32* pNameNeededChars, char * pNameBuffer, StringsExample_StringObject * pResult)
{
	IBase* pIBaseClass = (IBase *)pStringObject;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_INVALIDPARAM);
		if (pResult == nullptr)
			throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_INVALIDPARAM);
		std::string sName("");
		IBase* pBaseResult(nullptr);
		IStringObject* pIStringObject = dynamic_cast<IStringObject*>(pIBaseClass);
		if (!pIStringObject)
			throw EStringsExampleInterfaceException(STRINGSEXAMPLE_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			pBaseResult = pIStringObject->GetMyStringObject(sName);

			pIStringObject->_setCache (new ParameterCache_2<std::string, CStringsExampleStringObject *> (sName, pBaseResult));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, CStringsExampleStringObject *>*> (pIStringObject->_getCache ());
			if (cache == nullptr)
				throw EStringsExampleInterfaceException(STRINGSEXAMPLE_ERROR_INVALIDCAST);
			cache->retrieveData (sName, pBaseResult);
			pIStringObject->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (StringsExample_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		*pResult = (IBase*)(pBaseResult);
		return STRINGSEXAMPLE_SUCCESS;
	}
	catch (EStringsExampleInterfaceException & Exception) {
		return handleStringsExampleException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

StringsExampleResult StringsExample::Impl::StringsExample_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return STRINGSEXAMPLE_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return STRINGSEXAMPLE_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "stringsexample_stringobject_getmystringobject") 
		*ppProcAddress = (void*) &stringsexample_stringobject_getmystringobject;
	if (sProcName == "stringsexample_getversion") 
		*ppProcAddress = (void*) &stringsexample_getversion;
	if (sProcName == "stringsexample_getlasterror") 
		*ppProcAddress = (void*) &stringsexample_getlasterror;
	if (sProcName == "stringsexample_releaseinstance") 
		*ppProcAddress = (void*) &stringsexample_releaseinstance;
	if (sProcName == "stringsexample_acquireinstance") 
		*ppProcAddress = (void*) &stringsexample_acquireinstance;
	if (sProcName == "stringsexample_createstringobject") 
		*ppProcAddress = (void*) &stringsexample_createstringobject;
	
	if (*ppProcAddress == nullptr) 
		return STRINGSEXAMPLE_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return STRINGSEXAMPLE_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
StringsExampleResult stringsexample_getversion(StringsExample_uint32 * pMajor, StringsExample_uint32 * pMinor, StringsExample_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return STRINGSEXAMPLE_SUCCESS;
	}
	catch (EStringsExampleInterfaceException & Exception) {
		return handleStringsExampleException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

StringsExampleResult stringsexample_getlasterror(StringsExample_Base pInstance, const StringsExample_uint32 nErrorMessageBufferSize, StringsExample_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (StringsExample_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return STRINGSEXAMPLE_SUCCESS;
	}
	catch (EStringsExampleInterfaceException & Exception) {
		return handleStringsExampleException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

StringsExampleResult stringsexample_releaseinstance(StringsExample_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return STRINGSEXAMPLE_SUCCESS;
	}
	catch (EStringsExampleInterfaceException & Exception) {
		return handleStringsExampleException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

StringsExampleResult stringsexample_acquireinstance(StringsExample_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return STRINGSEXAMPLE_SUCCESS;
	}
	catch (EStringsExampleInterfaceException & Exception) {
		return handleStringsExampleException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

StringsExampleResult stringsexample_createstringobject(StringsExample_StringObject * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw EStringsExampleInterfaceException (STRINGSEXAMPLE_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateStringObject();

		*pInstance = (IBase*)(pBaseInstance);
		return STRINGSEXAMPLE_SUCCESS;
	}
	catch (EStringsExampleInterfaceException & Exception) {
		return handleStringsExampleException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


